12강 내용 정리
- 웹 브라우저에서 요청을 할때
1. 그 요청이 최초 : 서버는 쿠키를 만들어 세션 아이디를 만들어 넣고 헤더에 넣어 응답
2. 최초가 아님 : 요청 시 헤더에 받은 세션을 넣고 보내게 됨 > 서버는 그걸 보고 클라이언트를 판단. 다시 응답할때도 그대로 돌려줌

- 세션이 사라지는 경우
1. 서버에서 세션 값을 강제로 지웠을 때
2. 사용자가 브라우저를 종료
3. 세션 유효시간이 지났을 때 (보통 30분)

- 세션의 단점
로드 밸런싱(서버 분산)의 환경에서 이미 갔던 서버가 아닌 다른 서버에서 처리한다면 처음 요청받은 것처럼 되어버림
스티킹 서버(처음 간 서버를 기억해 계속 그 서버에서 처리하도록 함)나 세션 복제, 데이터베이스에 세션 저장(ex. redis) 등의 해결법이 있지만 번거로움

13강 내용 정리
통신은 OSI 7계층을 거쳐 이루어진다 (물데네전세표응)

- TCP 방식
> 신뢰성 있는 통신
TCP 방식은 항상 내가 보낸 데이터가 잘 갔는지를 항상 확인한다 (ACK로 연결 여부를 항상 확인)

- UDP 방식
> 신뢰성 없는 통신
어떤 상태여도 일단 데이터를 보냄 (속도는 TCP보다 빠름)

* 웹은 TCP 방식의 통신을 한다

14강 내용 정리

- CIA (C = 기밀성 / I = 무결성 / A = 가용성)
CIA를 지켜야 보안을 유지하는 것
CIA를 지켜도 문제가 생길 수 있음
문제1. 문서를 열기위한 열쇠를 어떻게 전달할 것인지
문제2. 탈취/위조를 어떻게 알아챌것인지 >> 열쇠로 잠그면 어느정도 막을 수 있음
문제3. 누구로부터 응답이 왔는지

문제1,3을 해결해야 한다

15강 내용 정리
- RSA
위의 문제를 RSA 암호화로 해결할 수 있다
public key : 공개키
private key : 개인키

A : A가 만든 공개/개인키가 있음
> A 개인키는 A만 소지 가능 / A 공개키는 외부 노출 가능
B : B가 만든 공개/개인키가 있음
> B 개인키는 B만 소지 가능 / B 공개키는 외부 노출 가능

A가 B에게 보안을 유지하며 문서를 보내려면?
공개된 B 공개키를 다운받아 잠궈서 전달
B는 B 개인키로 열어서 확인 (B 개인키를 가지고 있지 않으면 탈취해도 볼 수 없음!) >> 문제 1 해결 = 암호화

A가 A 비밀키를 이용해 문서를 잠그고 보냄
B가 이를 A 공개키로 열어서 확인 (A 비밀키는 A 공개키로만 열 수 있으니 A임을 알 수 있음!) >> 문제 3 해결 = 전자서명

사용하는 법
A가 B 공개키로 문서를 잠그고 A 개인키로 한번더 잠가서 보내면?
B가 A의 공개키로 열어보고
1. 열리면? 인증 OK > B 개인키로 열어 내용을 확인
2. 안열리면? 인증 X (탈취 가능성)



